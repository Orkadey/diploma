## Криминалистически правильные методы извлечения дампов оперативной памяти виртуальных машин в контексте платформы виртуализации QEMU/KVM

## Введение

### Актуальность

С расширением информатизации современного общества одновременно учащаются преступления в сфере информационных технологий. В связи с тем, что облачные вычисления, основанные на использовании платформ виртуализации, все чаще занимают центральное место в организации ИТ инфраструктур, у хакеров появляется большой стимул для получения доступа к виртуальной среде окружения. Таким образом растет необходимость в создании систем безопасности для противостояния киберпреступности.

Виртуализация обеспечивает уровень абстракции через эмуляцию аппаратного обеспечения и содействует распределению ресурсов между различными гостевыми машинами с различными операционными системами в форме виртуальных машин. Среда виртуализации состоит из нескольких виртуальных машин, монитора виртуальных машин, т. е. гипервизора и аппаратных средств, регулирующих доступ к ресурсам. Поскольку технологии виртуализации широко используются, лежащая в основе инфраструктура виртуализации становится потенциальной целью для атак [1].

Традиционные средства защиты операционных систем, такие как антивирусы, обеспечивают безопасность, используя перманентные агенты, установленные непосредственно внутри целевых систем. Главным недостатком такого подхода является уязвимость самих инструментов защиты перед вредоносным ПО, которое может, используя, скажем, нетривиальные комбинации эксплуатации неисправленных уязвимостей ядра и антиотладочные приемы, не только скрывать себя, но и блокировать программы-охранители.

Одним из решений, устраняющим недостатки является использование методов, имеющих в своей основе принципы компьютерной криминалистики - дисциплины о раскрытии и расследовании преступлений, связанных с компьютерной информацией, о методах получения и исследовании доказательств, имеющих форму компьютерной информации и о применяемых для этого технических средств [2]. Далее такие методы будем обобщать понятием «криминалистический подход». Ключевыми понятиями в определении компьютерной криминалистики являются получение и исследование доказательств, при этом необходимо придерживаться определенных требований, соответствующих целям данной дисплины:

* сохранение целостности и достоверности данных;
* предотвращение «загрязнения» данных;
* полная и правильная документация;
* реализация правильных научных методов.

### Классификации методов

Тематикой работы является извлечение компьютерной информации. Можно выделять множество классов методов, применяемых для получения данных. Классификация зависит от выбираемого критерия, например от типа памяти, с которой производится взаимодействие, таким образом, целью является

* энергозависимая память;
* энергонезависимая память.

Данная работа посвящена изучению и разработке методов первой группы. При этом получение дампа возможно с помощью

* программного обеспечения
* использования аппаратных средств.

Методы в той или иной степени могут удовлетворять требованиям криминалистического подхода к целостности и предотвращния «загрязнения» данных. По данному критерию можно выделить следующие группы методов:

* криминалистически правильные;
* криминалистически сомнительные;
* криминалистически неправильные.

Криминалистически правильные – методы, полностью удовлетворяющие требованиям криминалистического подхода. Применение криминалистически сомнительных методов не оказывает влияния на данные, однако не гарантирует сохранения целостности, т. е. получение данных не является атомарной операцией. Последняя группа подразумевает методы, непосредственно изменяющих данные, что нарушает их целостность и/или достоверность. В дальнейшем будем рассматривать только два последних класса методов.

Большая часть подходов к получению дампов памяти подразумевают использование дополнительно установленного программного обеспечения непосредственно на стороне целевой системы. Такие методы будем называть инвазивными. Соответственно выделим два класса по данному критерию:

* инвазивные;
* неинвазивные.

Необходимо также рассматривать возможность непрерывной работы целевой системы при ее исследовании, в частности, получения дампа оперативной памяти. В этом случае методы разделяют на:

* требующие остановки системы;
* не требующие остановки системы.

Примером неинвазивного, криминалистически правильного метода, требующего остановки системы является стандартная функция гипервизора QEMU/KVM pmemsave. При этом виртуальная машина приостанавливается гипервизором, после чего снимается дамп оперативной памяти. Подробнее о различных методах будет обсуждено далее.

### Актуальность работы

В случае облачных технологий, основанных на применении платформ виртуализации, наиболее эффективным является подход к противодействию несанкционированной активности внутри целевых систем, основанный на механизме интроспекции виртуальных машин для мониторинга и анализа операционных систем извне (со стороны гипервизора). Основное преимущество здесь заключается в отсутствии доступа вредоносного ПО из гостевых машин к памяти хоста и, параллельно, полном доступе к "физической" памяти виртуальных машин для резидентов хост-системы. В этом случае мы говорим о возможности: 

1. неинвазивного (т.е. без внедрения в гостевую память) изучения динамики оперативной памяти целевых систем; 
2. создания проактивной (упреждающей) защиты целевых машин на основе высокочастотного мониторинга на предмет появления гарантированно опасных или аномальных активностей в памяти.

### Цель работы

Данная работа посвящена изучению и разработке методов извлечения дампов оперативной памяти виртуальных машин. Необходимо учитывать определенные требования к разрабатываемому инструменту:

* изолированность инструментов от памяти исследуемой машины. Соблюдение данного условия обеспечивает целостность и корректность полученных данных;
* достоверность результата. Инструмент должен учитывать возможное воздействие вредоносных программ на любые функциональные уровни целевой машины;
* быстродействие. Мониторинг должен осуществляться в реальном времени.

### Задачи работы

Цель работы предполагает решения ряда соответствующих задач:

1. изучение методов получения дампов оперативной памяти;
2. выбор наиболее подходящего метода, обоснованность выбора;
3. разработка соответствующего программного комплекса для извлечения дампа памяти;
4. проведение эксперимента для верификации разработанного программного обеспечения.

## Глава 1

### Монитор виртуальных машин

На сегодняшний день существует множество различных гипервизоров и эмуляторов. Среди них большой популярностью пользуется QEMU (Quick Emulator), как одно из наиболее универсальных средств. Такие продукты, как VirtualBox, Xen имеют базовые составляющие QEMU [3]. В рамках данной работы важным преимуществом также является открытый исходный код эмулятора, а также поддерживаемость библиотекой libvirt, унифицирующий использование функционала различных мониторов виртуальных машин. В настоящее время QEMU используется совместно с модулем KVM (Kernel-based Virtual Machine), что обеспечивает высокую производительность. Говоря о QEMU/KVM, будем иметь ввиду именно совокупность данных инструментов. Для реализации методов необходимо иметь представления о реализации данной платформы.

> далее перемешано

### Устройство QEMU/KVM

QEMU — свободная программа с открытым исходным кодом для эмуляции аппаратного обеспечения различных платформ и виртуализации. Это означает, что QEMU обеспечивает возможность работы целевой операционной системы и всех ее приложений в виртуальной машине. QEMU может использоваться на разных операционных системах, таких как Linux, Windows и Mac OS X. Кроме главной цели, чем является запуск одной операционной системы на другой, QEMU может быть испоьзован для отладки, поскольку виртуальная машина может быть легко остановлена, и ее состояние может быть сохранено, проанализировано и восстановлено. 

KVM — это программное решение, обеспечивающее виртуализацию в среде Linux на платформе x86, которая поддерживает аппаратную виртуализацию на базе Intel VT (Virtualization Technology) либо AMD SVM (Secure Virtual Machine).

Программное обеспечение KVM состоит из загружаемого модуля ядра (называемого kvm.ko), предоставляющего базовый сервис виртуализации, процессорно-специфического загружаемого модуля kvm-amd.ko либо kvm-intel.ko, и компонентов пользовательского режима (модифицированного QEMU). Все компоненты ПО KVM являются ПО с открытым исходным кодом.

Сам по себе KVM не выполняет эмуляции. Вместо этого программа, работающая в пространстве пользователя, использует интерфейс /dev/kvm для настройки адресного пространства гостя виртуальной машины, через него же эмулирует устройства ввода-вывода и видеоадаптер. Иными словами, KVM использует ядро Linux как автономый гипервизор (тип 1), и на хосте выполняется не код KVM, а код ядра Linux и модуля KVM, являющегося частью ядра Linux, начиная с версии 2.6.12. Такой подход получает преимущество над гипервизорами, решающие задачи аппаратного и ресурсного управления, которые уже решены в ядре операционной системы. Linux представляет из себя монолитнию систему с отдельными элементами модульного ядра, поэтому предоставляет идеальную среду для построения гипервизора.

В настоящее время в QEMU идёт разработка поддержки технологий аппаратной виртуализации (Intel VT и AMD SVM) на x86-совместимых процессорах Intel и AMD. Первоначально разработка велась отдельно в рамках проекта Linux KVM , в котором, помимо собственно KVM (поддержки технологий аппаратной виртуализации x86-совместимых процессоров на уровне ядра Linux), разрабатывались патчи для QEMU, позволяющие QEMU использовать функциональность KVM. Однако недавно разработчики QEMU в содружестве с разработчиками KVM приняли решение в ближайшем будущем интегрировать поддержку KVM в основную ветку QEMU (mainline).

### KVM, общие сведения

Поскольку KVM использует ядро Linux, данный модуль работает с сетевыми картами, адаптерами хранилищ (storage adapter) и другим оборудованием, поддерживаемым ядром. Модуль безопасно исполняет код гостевой виртуальной машины непосредственно на CPU хоста, эффективность такого подхода обеспечивается поддержкой технологии аппаратной виртуализации, которая добавляет режим выполнения, позволяющий поддерживать работу гостевых машин без необходимости предоставления им полного доступа к памяти и ресурсам. 

В то время как код гостевой машины исполняется непосредственно на CPU хоста, большинство I/O запросов перехватываются, вместо их непосредственной отправки напрямую к устройствам хоста. Гостевая машина видит сэмулированный чипсет и PCI шину, на которых могут быть установлены как сэмулированные так и passthrough **(формулировка?)** адаптеры. KVM предоставляет особенности паравиртуализированных драйверов балунинга памяти (memory ballooning), сетевых соединений и хранилищ данных, которые увеличивают эффективность ввода/вывода и позволяют управлять количеством доступной оперативной памяти, выделяемой гостевой машине.

Эмуляция устройств производится процессом qemu-kvm пользовательского пространства на хосте. Это позволяет модулю ядра сфокусироваться на аспектах наиболее критических в плане производительности, в то время как эмуляция устройств пользовательского пространства эмулирует аппаратное обеспечение в изолированном процессе вне ядра системы. Технология sVirt блокирует процесс qemu-kvm с помощью SELinux MAC (Mandatory Access Control) таким образом, чтобы ему предоставлялся доступ только к необходимиым файлам и ресурсам.

Инструменты управления должны следить и получать доступ к гостевым системам, которые могут быть запущены на удаленных физических машинах, либо локально. Это осуществляется с помощью множества API и утилит, включающие приложения для манипулирования гостевыми машинами и автоматизирования задач управления. Libvirt предоставляет функции и утилиты командной строки для разработки приложений и написания скриптов. На каждом хосте работает демон libvirt, который обеспечивает безопасный API удаленного управления, но также может быть сконфигурирован для исключительно локального использования. Демон libvirt сохраняет настройки гостевой системы и является центральной точкой для установления сетевых соединений и хранилищ.

Большая часть администрирования происходит с использованием API библиотеки libvirt, в особенности инструмента virsh, который предоставляет оперции управления гостевой системой и хостом. Ту же цель имеет графический инструмент virt-manager. Сторонние инструменты такие как OpenStack могут быть использованы для высокоуровнего управления датацентрами и, чаще всего, интегрируемы с libvirt.

### API управления памятью, структура памяти

API управления памятью моделирует память, шины ввода/вывода и контролеры гостевой машины. Он позволяет моделировать:

* обычную оперативную память;
* MMIO (memory-mapped I/O);
* контролеры памяти, которые могут динамически перенаправлять регионы физической памяти по различным направлениям.

Модель памяти обеспечивает поддержку

* отслеживания изменений оперативной памяти гостевой системы
* подготовки объединенной памяти (coalesced memory) для KVM
* установки ioeventfd регионов для KVM

Модель памяти представляет из себя ациклический граф объектов MemoryRegion. Листьями являются регионы оперативной памяти и MMIO, остальные узлы представляют шины, контролеры памяти и перенаправленные регионы памяти. В дополнение к объектам MemoryRegion, API предоставляет объекты AddressSpace для каждого корня и промежуточных объектов MemoryRegion. Они отображают память так, как она видима с точки зрения CPU или устройств.

В данной модели существуют четыре типа регионов памяти (все являются типом MemoryRegion):

* RAM. RAM является блоком оперативной памяти хоста, которая может быть использована гостевой системой.
* MMIO. Блоки памяти гостевой машины, которые имплементированы функциями обратного вызова хоста, т. е. каждая операция чтения и записи означает вызов функции обратного вызова на хосте.
* контейнер (container). Контейнер включает в себя другие регионы памяти, каждый из которых располагается по разным адресам. Контейнеры используются для группирования нескольких регионов в один, например, PCI BAR может быть представлен в виде объединения регионов RAM и MMIO. Регионы составляющие контейнер обчыно не перекрываются. В некоторых случаях удобным оказывается использование перекрывающихся регионов, например, для котролера, который может перекрывать субрегионы RAM регионами MMIO или ROM.
* alias.**(формулировка?)** Является секцией региона памяти, позволяют разделить регион памяти на непересекающиеся регионы. Примером служат банки памяти, когда адресное пространство гостевой системы меньше, чем количество адресованной оперативной памяти. Данный тип может указывать на регион памяти любого типа, включая сам тип, но не на себя.

Таже допустимо добавлять субрегионы к регионам, которые не являются контейнерами (MMIO, RAM или ROM). Это означает, что регион будет вести себя как контейнер, за исключением случая, когда любые адреса внутри региона, которые не востребованы субрегионом, обрабатываются самими контейнерами. Однако такой эффект достижим и с помощью контейнера, один из субрегионов которого является регионом с низким приоритетом, покрывающим весь диапазон адресов.

Регионы создаются одной из функций memory_region_init*() и прикрепляются к обекту, который действует как их родитель/владелец. QEMU гарантирует, что объект-владелец остается активным до тех пор, пока регион остается видимым для гостевой системы, либо пока используется виртуальным CPU или другим утройством. Например, объект-владелец будет присутствовать между операцией address_space_mmap и соответсвующей операцией address_space_munmap. После создания регион может быть добавлен к адресному пространству или контейнеру с помощью функции memory_region_add_subregion() и удален функцией memory_region_del_subregion().

Ядро памяти использует следующий набор правил для выбора региона при доступе к определенному адресу:

* все подрегионы корневого региона сопоставляются с адресом в порядке убывания приоритета;
  * если адрес лежит вне региона адрес/размер, субрегион отбрасывается;
  * если субрегион является листом (RAM, MMIO), поиск прекращается, возвращая субрегион;
  * если субрегион является контейнером, алгоритм выполняется заново для данного субрегиона, адрес регулируется значением адреса субрегиона;
  * если субрегион - alias, поиск продолжается в данном субрегионе, адрес регулируется значением адреса субрегиона;
  * если рекурсивный поиск внутри контейнера или субрегиона alias не дает результат из-за наличия "дыры" в покрытии контейнером его адресного диапазона, тогда, в случае если контейнер опирается на собственный MMIO или RAM, поиск прекращается, возвращая контейнер, иначе поиск продолжается в субрегионах в порядке приоритета;
* если никакой из субрегионов не соответствует адресу, поиск прекращается с результатом отсутствия соответствия.

Пример структуры памяти:

```
system_memory: container@0-2^48-1
 |
 +---- lomem: alias@0-0xdfffffff ---> #ram (0-0xdfffffff)
 |
 +---- himem: alias@0x100000000-0x11fffffff ---> #ram (0xe0000000-0xffffffff)
 |
 +---- vga-window: alias@0xa0000-0xbfffff ---> #pci (0xa0000-0xbffff)
 |      (prio 1)
 |
 +---- pci-hole: alias@0xe0000000-0xffffffff ---> #pci (0xe0000000-0xffffffff)

pci (0-2^32-1)
 |
 +--- vga-area: container@0xa0000-0xbffff
 |      |
 |      +--- alias@0x00000-0x7fff  ---> #vram (0x010000-0x017fff)
 |      |
 |      +--- alias@0x08000-0xffff  ---> #vram (0x020000-0x027fff)
 |
 +---- vram: ram@0xe1000000-0xe1ffffff
 |
 +---- vga-mmio: mmio@0xe2000000-0xe200ffff

ram: ram@0x00000000-0xffffffff

```
Блок оперативной памяти размером 4GB отображен на адресное пространство системы через два региона типа alias:

* "lomem" - отображение 1:1 первых 3.5GB;
* "himem" - отображение последних 0.5GB по адресу 4GB (0x100000000).

Такое отображение оставляет 0.5GB для так называемой "PCI hole", которая позволяет 32-хбитной PCI шине существовать в системе с 4GB памяти. Контролер памяти направляет адреса в диапазоне 640K-780K в адресное пространство PCI. Это моделируется при помощи региона "vga-window", отображенного с большим приоритетом таким образом, что затеняет RAM в том же диапазоне адресов. Данный регион может быть устранен при програмировании контролера памяти, путем устранения alias-региона и выявления нижележащего RAM.

Адресное пространство PCI не является прямым потомком системного адресного пространства, поскольку видимыми должны быть только его части. У данного адресного пространства есть два субрегиона: "vga-area" моделирует устаревшее vga окно (vga window) и занимает два банка памяти размером 32KB указывающих на две секции кадрового буфера (framebuffer). В дополнение, по адресу e1000000 vram отображен как BAR и дополнительный BAR после него, содержащий MMIO регистры.

## Глава 2

### Существующие методы

Кратко разберем некоторые существующие методы получения дампов и подробнее рассмотрим те из них, которые представляют наибольший интерес.

*Tribble* - PCI карта расширения (PCI expansion card), которая может использоваться для получения содержимого физической памяти. Данный метод имеет свои сильные стороны и ограничения. Как аппаратное средство, Tribble может получать доступ к памяти без установки дополнительного программного обеспечения. Однако данное утройство не получило распространения из-за необходимости предварительной установки, что является серьезным недостатком для криминалистических исследований. 

Другим решением с использованием аппаратных средств являются устройства *Firewire*, которые используют прямой доступ к памяти (Direct Memory Access, DMA), в обход центрального процессора. Мэппинг памяти (memory mapping) производится в аппартной среде, в обход операционной системы, что обеспечивает высокоскоростное копирование. Проблема данного метода лежит в вопросе с UMA (Upper Memory Area), что иногда вызывает сбой системы.

Такие подходы, являются неинвазивным и не требующим остановки системы, однако целостность данных не сохраняется, поскольку целевая система не останавливается и данные изменяются, иными словами метод криминалистически сомнительный. Приоритетом в рамках поставленной задачи пользуется все же программное обеспечение, поскольку с помощью него можно достигнуть схожих результатов без необходимости приобретения устройств копирования.

Аварийные дампы Microsoft. Несмотря на то, что данный метод неинвазивный и криминалистически правильный, у него мало преимуществ перед другими подходами, так как необходимо изменять настройки системы, а в общем случае перезагрузить систему для приведения настроек в действие. Помимо этого, система не просто приостанавливается, но полностью завершает работу.

Belkasoft Live RAM Caputer – инструмент, который может получать дампы оперативной памяти, запускаясь при этом с USB-флеш-накопителя. Данный метод можно классифицировать как инвазивный, криманилистически сомнительный, не требующий остановки целевой системы. Инвазивность заключается в выполнении кода программы в оперативной памяти, то же является и причиной криминалистической сомнительности. То же можно сказать о продуктах действующих по похожему принципу, таких как MANDIANT Memoryze, HBGary, FTK Imager.

Целью данной работы является получение дампов памяти виртуальных машин, что делает выбор соответствующих методов более широким. Из описания работы гипервизора QEMU/KVM в **первой главе ** можно сделать вывод, что оперативная память виртуальной машины, в сущности, является выделенным блоком памяти хоста, который располагается внутри процесса, поэтому можно применять методы, получающие лишь часть оперативной памяти, выделенной для процесса.

Чтение памяти, выделенной процессу. /proc/$pid/mem показывает содержимое отображения памяти $pid таким же образом, как в процессе, т. е. байт на позиции *x* в псевдо-файле тот же, что и байт на позиции *x* в процессе. Если память освобождается по определенному адресу, чтение из соответствующего файла приведет к ошибке EIO (Input/output error). Например, поскольку первая страница процесса никогда не отображается, чтение первого байта /proc/$pid/mem всегда вызывает ошибку EIO. Чтобы найти корректные части памяти процесса достаточно прочитать /proc/$pid/maps. Данный файл содержит по одной линии на соответствующий регион памяти, что выглядит следующим образом:
```
08048000-08054000 r-xp 00000000 08:01 828061     /bin/cat
08c9b000-08cbc000 rw-p 00000000 00:00 0          [heap]
```
Первые два числа являются границами региона (адреса первого байта и байта, следующего за последним, в шестнадцатиричном формате). Далее указаны права доступа, после содержится некоторая информация о файле, если это отображение файла. 

Попытка чтения /proc/$pid/mem из другого процесса обычным способом приводит к ошибке ESRCH (Процесс не существует). Указанные права доступа для /proc/$pid/mem показывают больший доступ, чем, по существу, есть на самом деле. Кроме того, попытка чтения памяти процесса в то время, пока процесс ее изменяет, может дать некорректный вид памяти. Таким образом необходимо производить дополнительные операции:

* процесс, желающий читать /proc/$pid/mem должен присоединиться к соответствующему процессу с помощью функции ptrace() с флагом PTRACE_ATTACH. Данную процедуру выполняют отладчики при отладке процесса. По окончании чтения из /proc/$pid/mem, процесс должен вызвать функцию ptrace() с флагом PTRACE_DETACH для прерывания соединения.
* процесс, чья память считывается не должен выполняться в момент считывания. Обычно, вызов функции ptrace(PTRACE_ATTACH, ...) останавливает целевой процесс (посылает сигнал STOP), но из-за состояния гонки (доставка сигнала асинхронна), поэтому вызывающий процесс должен использовать функцию wait().

Метод, использующий описанный алгоритм, имплементирован в GDB (GNU Debugger) и может быть применен простым скриптом:
```
#!/bin/bash

grep rw-p /proc/$1/maps | \
sed -n 's/^\([0-9a-f]*\)-\([0-9a-f]*\) .*$/\1 \2/p' | \
while read start stop; \
do gdb --batch --pid $1 -ex "dump memory $1-$start-$stop.dump 0x$start 0x$stop"; \
done

```
Такой подход является неинвазивным и криминалистически правильным, однако требует остановки процесса, что, в свою очередь, означает остановку целевой системы. 

Для улучшения данного метода возможным является дополнительное использование функции fork(), с целью создания копии адресного пространства процесса с механизмом копирования при записи (COW, Copy-On-Write). Однако использование функции fork() применительно к многопоточному процессу не является корректным, поскольку копируется единственный поток, из которого применялся вызов функции. Идея все же была осуществлена в инструменте google-coredumper, целью которого является получение дампа памяти многопоточного процесса, читаемого с помощью GDB. Функции данной библиотеки моментально останавливают все потоки, создавая копию адресного пространства процесса с механизмом копирования при записи. К сожалению, из-за сложностей реализации инструмент не оказался достаточно универсальным, с выходом новых версий ядра Линукса (Linux) google-coredumper перестал корректно работать. Несмотря на это, концепция метода является привлекательной, поскольку такой подход одновременно является криминалистически правильным, не требующим остановки процесса, неинвазивным и, ко всему прочему, потенциально имеет различные применения в решении ряда других задач.

Наиболее практичным методом получения дампа оперативной памяти представляется использование средств гипервизора. Мониторы виртуальных машин среди стандартных функции, как правило, имеют функции сохранения состояния виртуальной машины и создания дампов оперативной памяти гостевой системы. В качестве примера команды  сохранения состояния можно привести команду savevm рассматриваемого гипервизора QEMU/KVM. Общий алгоритм работы представляет из себя набор последовательных операций:

* приостановка работы гостевой операционной системы;
* копирование блоков памяти, сопряженное с наложениями блокировок и вычеслинеями дельты, т. е. разности между текущим и предыдущим состоянием виртуальной машины;
* восстановление работы гостевой операционной системы, что далеко не во всех случаях означает тривиальную "разморозку" виртуальной машины.

Практически все методы получения дампа оперативной памяти с помощью гипервизора сводятся к набору вышеперечисленных операций, среди которых важной является приостановка работы гостевой операционной системы, что обеспечивает целостность считываемх данных. Это обуславливается тем, что основной целью таких функций является либо сохранение состояния виртуальной машины для последующего восстановления, либо для анализа содержимого ее оперативной памяти. Таким образом, такие методы можно объединить в одну группу криминалистически правильных, неинвазивных, требующих остановки целевой системы. Кроме того стоит заметить, что использование конкретных функций одного гипервизора является далеко не лучшим решением по критерию универсальности, поэтому следует принять в рассмотрение более общие подходы.

### Реализуемый метод

Универсальной библиотекой для работы с различными гипервизорами является libvirt. Целью библиотеки libvirt является обеспечение общим и стабильным инструментом для управления доменами в узле, и, если возможно, удаленно. Под узлом здесь подразумевается отдельная физическая машина, под доменом - отдельная операционная система, работающая на виртуальной машине. Таким образом, libvirt предоставляет все функции, необходимые для управления: создание, изменение, мониторинг, контроль, миграция и остановка доменов - все в пределах поддержки данных операций гипервизором. libvirt поддерживает различные гипервизоры, включая QEMU/KVM, Xen, VirtualBox, Microsoft Hyper-V и другие.

Общий алгоритм работы реализуемого метода содержит стандартный набор операций, применяемых для получения дампов оперативной памяти. Рассмотрим подробно последовательность операций для формирования четкого представления о методе и возможности его применения на практике.

1. Создание хранилища дампа. В зависимости от решаемой задачи дамп оперативной памяти гостевой машины можно хранить:

  * в энергозависимой памяти (оперативной памяти);
  * в энергонезависимой памяти.

   Преимущества и недостатки использования разных типов памяти будут наглядно продемонстрированы в **следующей главе**. 

   Как правило, запись и хранение дампа в оперативной памяти дает большое преимущество в плане быстродействия алгоритма, однако предполагает наличие большого ее количества. Для выделения достаточно большого блока памяти используется комбинация функций shm_open(), mmap() и ftruncate() для создания файлового дескриптора, ссылающегося на область памяти, выделения область памяти и ее инициализации соответственно. При этом выделенный блок памяти остается зарезервированным даже после завершения процесса, таким образом на пользователя ложится ответственность за своевременное освобождение памяти, что осуществляется вызовом функции shm_unlink().

   Запись дампа в энергонезависимую память дает преимущество его долговременного хранения. Оптимальным вариантом для записи в данном случае является использование функции open(), аналогом которого является вышеупомянутая функция shm_open(). Функция open() создает файловый дескриптор на файл, хранящийся в энергонезависимой памяти. Таким образом, отличие от случая с оперативной памятью заключается в более длительном доступе к энергонезависимой памяти.

   Для обоих случаев выделение региона памяти осуществляется с помощью функции mmap(), поскольку это обеспечивает оптимальный вариант при работе с большими массивами данных. Причиной этому служит низкая гранулярность применяемых операций, что уменьшает число обращений к операционной системе. Другой выжной причиной является то, что операционная система оптимизированно обрабатывает запросы на чтение и запись, применяя операции только в случае необходимости.
 
2. Копирование блока памяти. Основной функцией на этом шаге является virDomainMemoryPeek(), принимающей в качестве аргументов указатель на домен, значение которого косвенно определяется пользователем, стартовый адрес блока читаемой памяти, его размер, адрес буфера, куда записывется результат, а также флаг, отвечающий за тип читаемой памяти. Адрес домена определяется одной из функций, принимающих в качестве аргумента один из однозначно определенных параметров домена: идентификационный номер, имя, UUID (Universally Unique Identifier). Стартовый адрес блока читаемой памяти может быть интерпретируем по-разному, в зависимости от значения флага:
 
  * VIR_MEMORY_VIRTUAL - указанный адрес блока читаемой памяти является адресом в виртуальном адресном пространстве гостевой операционной системы;
  * VIR_MEMORY_PHYSICAL - указанный адрес блока читаемой памяти является физическим адресом.
  
   В данной задаче предпочтительно выбрать значение VIR_MEMORY_PHYSICAL, поскольку использование виртуальных адресов сводится к их трансляции в соответсвующий физический адрес, что означает привлечение дополнительных операций. Кроме того, значения необходимых физических адресов в случае снятия полного дампа тривиальны (стартовый адрес 0).
   
   Далее подробно рассмотрим работу функции virDomainMemoryPeek(), разделив этап на несколько более простых шагов, поскольку в данном случае копирование производится нетривиальным способом.
   
  1. Установка блокировки. Используя функцию rcu_read_lock() на читаемый регион памяти устанавливается блокировка, основывающаяся на механизме read-copy-update (RCU). Ключевое свойство такой блокировки заключается в том, что потоки, производящие чтение, могут получать доступ к данным, даже если происходит их обновление. Такой эффект достигается за счет дополнительных затрат на сохранение старой версии данных. Так как достаточно значительную часть оперативной памяти составляют статичные структуры, такая блокировка не несет неприемлемых затрат, при этом она обеспечивает целостность считываемых данных.
  
  2. Формирование и отправка сообщения гипервизору. Основную часть управления библиотека libvirt производит через вызов соответствующих функций гипервизора. Для этого необходимая команда представляется в виде, присущем гипервизору, например, в случае QEMU/KVM используется формат QEMU Machine Protocol (QMP), базирующийся на формате JSON. Далее, используя формат сериализации External Data Representation (XDR), данная команда передается гипервизору в виде сообщения, где после процедуры десериализации сообщения гипервизор выполняет необходимые действия.
  
  3. Выполнение команды гипервизором. В рассматриваемом случае выполняется команда pmemsave. Данная команда вызывает соответствующую функцию qmp_pmemsave(). Сначала производится поиск соответствующего блока памяти процесса, откуда необходимо произвести чтение, что сопровождается трансляцией адреса виртуального адресного пространства в физический адрес. Далее производится чтение из блока памяти в буфер при помощи функции memcpy(), которая имеет свойство потоковой безопасности по стандарту POSIX, или иными словами имеет свойство реентерабельности. Это в свою очередь означает, что не обрабатываются случаи обновления данных во время их чтения. В случае использования данной функции непосредственно гипервизором такая ситуация учитывается путем приостановки виртуальной машины, в приведенном же случае данную проблему устраняет установленная ранее блокировка.
  
  4. Завершение этапа. Результат возвращается в тело функции virDomainMemoryPeek() аналогично отправке сообщения гипервизору, после чего копируется в указанный буфер. Процесс завершается снятием блокировки функцией rcu_read_unlock() и освобождением ресурсов.
  
## Глава 3.

### Постановка эксперимента

Цель эксперимента - показать состоятельность метода применительно к решению поставленных задач и обозначить наиболее важные характеристики реализованного метода. В связи с этим в эксперимент необходимо включить следующие пункты:

* проверка корректности метода, означающая соответсвие требованиям криминалистически правильных или криминалистически сомнительных методов и характеризующаяся наличием этапов:

  * проверка целостности копируемых блоков памяти;
  * проверка корректности полученного дампа памяти оперативной памяти;
  
* выявление преимуществ и недостатков реализованного метода в сравнении со стандартнымы методами получения дампов, главным образом, подхода, реализованного функцией pmemsave гипервизора QEMU/KVM.

## Список литературы

1. Thu Yein Win, Huaglory Tianfield, Quentin Mair. Virtualization Security Combining Mandatory Access Control and Virtual Machine Introspection. UCC '14: Proceedings of the 2014 IEEE/ACM 7th International Conference on Utility and Cloud Computing. December 2014. 1004 p.
2. Федотов Н.Н. Форензика – компьютерная криминалистика. Москва: «Юридический мир», 2007. 360 с.

3. http://qemu.weilnetz.de/qemu-tech.html#QEMU-Internals

4. Naja Davis. Live Memory Acquisition for Windows Operating Systems:  Cover Page and Abstract Tools and Techniques for Analysis. Eastern Michigan University. 4 – 6 p.

>Для доказательства что реализован криминалистичски правильный метод (фактически нет "криминалистически сомнительного", наверное).
Rodney McKemmish. When is Digital Evidence Forensically Sound? Advances in Digital Forensics IV. IFIP — The International Federation for Information Processing Volume 285, 2008, pp 3-15


    